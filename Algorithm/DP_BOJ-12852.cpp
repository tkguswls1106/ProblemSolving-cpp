// - DP 문제 (바텀업 방식 / 경로 추적) -
// DP 문제이지만, BFS로도 풀 수 있는 문제임.
// 참고로 이 코드는 DP 풀이방식을 사용하였음. (그중에서 바텀업 방식)
// 이 문제는 DP-Basic_BOJ-1463.cpp 문제코드의 경로추적 기능 추가 버전이다.

#include <iostream>
#include <algorithm>

using namespace std;

// - DP 문제 풀이과정:
// * 과정 1. DP테이블 정의하기:
// DP[i]는 i를 1로 만들기위해 필요한 연산 사용 횟수의 최솟값
// * 과정 2. 점화식 찾기:
// 예시로 DP[12]는 무엇인가?를 생각하면 (참고로 밑의 +1의 의미는 연산횟수+1이다.)
// '3으로 나누거나' => 'DP[12] = DP[12/3] + 1 = DP[4] + 1' => 'DP[k] = DP[k/3] + 1'
// '2으로 나누거나' => 'DP[12] = DP[12/2] + 1 = DP[6] + 1' => 'DP[k] = DP[k/2] + 1'
// '1을 빼거나' => 'DP[12] = DP[12-1] + 1 = DP[11] + 1' => 'DP[k] = DP[k-1] + 1'
// 결론적으로 DP[k]는 위의 세조건중 최솟값으로 결정되면 됨.
// ==> DP[k] = min(DP[k/3]+1, DP[k/2]+1, DP[k-1]+1)
// * 과정 3. 초기값 정의하기:
// 이 문제의 경우에는, 'DP[k] = DP[k/3] + 1' 처럼 항이 하나이므로, 한가지의 초기값 할당이면 된다.
// 그리고 1(=i)을 1로 만들기위해 필요한 연산 사용 횟수의 최솟값은 0이므로, 초기값으로 'DP[1] = 0'만 할당해주면 충분하다.
// 하지만 예를들어 피보나치의 경우에는, 점화식이 'DP[i] = DP[i-1] + DP[i-2]'로써 두가지의 초기값 할당이 필요하다.

int dp[1000002] = { 0, };  // dp 값 테이블
int pre[1000002] = { 0, };  // 경로 복원용 테이블 (prev[a]=b 란, 숫자 a의 다음경로는 b라는것을 의미함.)

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    dp[1] = 0;  // DP 점화식 초기값 할당. 이 문제에서는 한가지만해도 됨. 이유는 위의 설명 주석에 작성해두었음.
    pre[1] = -1;  // 더이상 역으로 검색할 경로가 없음을 의미.

    for(int i=2; i<=n; i++) {  // DP 테이블에 미리 값을 채워줌. (바텀업 방식이므로 재귀함수 대신 반복문 사용으로 미리 값들을 세팅)
        dp[i] = dp[i-1] + 1;
        pre[i] = i-1;
        
        if(i%3 == 0 && dp[i] > dp[i/3]+1) {
            dp[i] = dp[i/3]+1;
            pre[i] = i/3;
        }
        if(i%2 == 0 && dp[i] > dp[i/2]+1) {
            dp[i] = dp[i/2]+1;
            pre[i] = i/2;
        }
    }

    cout << dp[n] << "\n";
    int now = n;
    while(true) {
        cout << now << " ";
        if(pre[now] == -1) {  // 이거 또는 if(now == 1) 로도 가능하다.
            break;
        }

        now = pre[now];
    }


    return 0;
}