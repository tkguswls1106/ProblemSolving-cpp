// - 그리디알고리즘 동전 문제 -

#include <vector>
#include <iostream>

using namespace std;

// [ 그리디알고리즘 - 백준 11047 문제 ]

// - 그리디 알고리즘이란?:
// 그리디 알고리즘은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 뜻하며, 이는 탐색 범위를 줄일 수 있다.
// 하지만 이는 순간마다 하는 선택은 지역적으로는 최선이자 최적이지만, 최종적인 결과 도출에 대한 최적해를 보장할 수는 없다. 그렇기에 해당 문제에 대해 사용가능여부를 판단해야한다.
// 이는 즉, 특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해도 풀 수 있는 문제인지를 파악할 수 있어야 한다는 것이다.

// - 이 문제에서는 그리디를 적용하여 큰 금액의 동전부터 차감하면 최적해를 도출 가능하다. 이유는?:
// 문제의 조건을 보면, '오름차순 1 ≤ Ai ≤ 1,000,000'에서 'A1 = 1, i ≥ 2'인 경우에 'Ai는 Ai-1의 배수'라고 나와있다.
// 이러한 경우에는 무조건 Ai를 안쓰고 Ai-1,Ai-2... 들을 이용해 Ai를 쓴 경우보다 적게 만들 수 없다.
// 이는 즉, 큰 금액의 동전부터 차감하는 방식의 그리디를 적용하는 것에대해 반례가 없으며 최적해를 구할 수 있기에, 그리디 알고리즘을 사용해도 된다고 사용가능여부의 정당성을 판단할 수 있는 것이다.
// - 결론:
// 거스름돈같은 동전 문제는, 매 순간마다 가능한 큰 동전을 우선적으로 최대한 많이씩 선택하는게 가장 좋은 선택이다.
// 하지만 이는 큰동전이 그보다 한단계 작은 동전의 배수일 경우에만 가능한 일이다.
// 예시로, 동전의 종류가 '500,100,50,10원'인 문제라면, '500=100*5, 100=50*2, 50=10*5'로 위의 조건에 부합하기에, 이 문제에 그리디 알고리즘을 적용해도 최적해를 보장받을 수 있기에 풀이에 사용해도 적절하다.
// - 반례 예시:
// 반례의 예시로는, 어떠한 문제에서 동전의 종류가 '500,400,100원' 이라면, 500은 400의 배수가 아니기에 그리디 적용은 적절치 못하다.
// 이를 증명하자면, 예를들어 총 800원이 나와야할때, 여기에 그리디 알고리즘을 적용해서 최대 동전부터 선택하는 방법으로 풀어버린다면 '500*1 + 100*3'으로 동전의 최소 개수가 4개로 결과가 나오지만,
// 실은 답이 4개가 아닌 '400*2'로써 2개로 최솟값 답을 구할수 있기에, 이 문제에는 그리디 알고리즘 사용이 적절치않았지만 사용했기에 틀린것을 알 수 있다.
// 이처럼 큰 단위가 그보다 한단계 작은 단위의 배수가 아니라면 이와 같은 그리디 알고리즘을 이용해서 최적의 해를 보장할 수 없음을 알 수 있다.

// - 동전문제에 그리디 알고리즘 적용시, 시간복잡도:
// 그리고 이 문제는 그리디 알고리즘으로 풀을시에, 동전의 종류가 N가지라면 N만큼의 시간복잡도인 O(N)을 가지게 된다.
// 이는 금액총액과는 무관하며 오직 동전의 종류 수에만 영향을 받는다.

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int n,k;  // n은 동전종류개수, k는 금액총합
    vector<int> coinTypeV;

    cin >> n >> k;
    while(n--) {
        int coinType;
        cin >> coinType;
        coinTypeV.push_back(coinType);
    }

    int coinCnt = 0;
    for(int i=coinTypeV.size()-1; i>=0; i--) {  // 벡터를 뒤에서부터 앞으로 순회.
        int coinType = coinTypeV[i];
        coinCnt += (k / coinType);
        k %= coinType;
    }
    cout << coinCnt;


    return 0;
}